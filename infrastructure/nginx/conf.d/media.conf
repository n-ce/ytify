# ============================================================================
# YTFY Nginx Media Streaming Configuration
# ============================================================================
# Purpose: Optimized configuration for audio/video streaming
# Features: Range requests, slice caching, efficient streaming
# ============================================================================

# ==========================================================================
# Media Streaming Location Block
# ==========================================================================

# Audio streaming endpoint
location ~ ^/stream/audio/ {
    # Proxy to backend for audio streams
    proxy_pass http://ytify_backend;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # =======================================================================
    # Range Requests Support (Essential for media seeking)
    # =======================================================================
    
    # Pass range requests to upstream
    proxy_set_header Range $http_range;
    proxy_set_header If-Range $http_if_range;
    
    # Accept byte range responses
    proxy_force_ranges on;
    
    # =======================================================================
    # Buffer Configuration for Streaming
    # =======================================================================
    
    # Enable buffering for smooth playback
    proxy_buffering on;
    
    # Large buffers for media content
    proxy_buffer_size 128k;
    proxy_buffers 8 256k;
    proxy_busy_buffers_size 512k;
    
    # Temp file settings (for large responses)
    proxy_max_temp_file_size 1024m;
    proxy_temp_file_write_size 256k;
    
    # =======================================================================
    # Caching Configuration
    # =======================================================================
    
    # Use media cache zone
    proxy_cache media_cache;
    
    # Cache both full and partial (206) responses
    proxy_cache_valid 200 206 24h;
    proxy_cache_valid 404 1m;
    
    # Include range in cache key for slice caching
    proxy_cache_key "$scheme$request_method$host$uri$slice_range";
    
    # Serve stale content while updating
    proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
    proxy_cache_background_update on;
    
    # Lock to prevent cache stampede
    proxy_cache_lock on;
    proxy_cache_lock_timeout 10s;
    
    # Add cache status header
    add_header X-Cache-Status $upstream_cache_status;
    
    # =======================================================================
    # Timeout Configuration
    # =======================================================================
    
    # Longer timeouts for media streaming
    proxy_connect_timeout 30s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
    
    # =======================================================================
    # CORS Headers for Media
    # =======================================================================
    
    add_header Access-Control-Allow-Origin $cors_origin always;
    add_header Access-Control-Allow-Methods "GET, HEAD, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Range, If-Range" always;
    add_header Access-Control-Expose-Headers "Content-Length, Content-Range, Accept-Ranges" always;
    
    # =======================================================================
    # Content Headers
    # =======================================================================
    
    # Accept ranges header
    add_header Accept-Ranges bytes always;
}

# ==========================================================================
# Static Media Files (served directly by Nginx)
# ==========================================================================

location ~ ^/media/ {
    # Root for static media files
    alias /var/www/ytify/media/;
    
    # =======================================================================
    # Sendfile Optimization
    # =======================================================================
    
    # Enable sendfile for zero-copy serving
    sendfile on;
    
    # Optimize TCP for streaming
    tcp_nopush on;
    tcp_nodelay on;
    
    # Async I/O for large files
    aio threads;
    directio 512k;
    
    # Output buffers for streaming
    output_buffers 2 1m;
    
    # =======================================================================
    # Range Requests for Static Files
    # =======================================================================
    
    # Nginx automatically handles range requests for static files
    # The Accept-Ranges header is added automatically
    
    # =======================================================================
    # Caching Headers
    # =======================================================================
    
    # Long-term cache for media files
    expires 30d;
    add_header Cache-Control "public, max-age=2592000";
    
    # ETag for validation
    etag on;
    
    # =======================================================================
    # MIME Types
    # =======================================================================
    
    # Ensure correct MIME types for audio/video
    types {
        audio/mpeg mp3;
        audio/ogg ogg oga;
        audio/opus opus;
        audio/webm weba;
        audio/aac aac;
        audio/flac flac;
        audio/wav wav;
        audio/x-m4a m4a;
        video/mp4 mp4;
        video/webm webm;
        video/ogg ogv;
        application/x-mpegURL m3u8;
        video/MP2T ts;
    }
    
    # Prevent MIME sniffing
    add_header X-Content-Type-Options "nosniff" always;
}

# ==========================================================================
# HLS/DASH Streaming Support
# ==========================================================================

# HLS manifest files
location ~ \.m3u8$ {
    # No cache for manifests (they update frequently)
    expires -1;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    
    # CORS for HLS
    add_header Access-Control-Allow-Origin $cors_origin always;
    add_header Access-Control-Allow-Methods "GET, HEAD, OPTIONS" always;
    
    # Content type
    add_header Content-Type "application/vnd.apple.mpegurl" always;
}

# HLS segment files
location ~ \.ts$ {
    # Cache segments
    expires 1h;
    add_header Cache-Control "public, max-age=3600";
    
    # CORS for HLS
    add_header Access-Control-Allow-Origin $cors_origin always;
}

# DASH manifest files
location ~ \.mpd$ {
    # No cache for manifests
    expires -1;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    
    # CORS for DASH
    add_header Access-Control-Allow-Origin $cors_origin always;
    add_header Access-Control-Allow-Methods "GET, HEAD, OPTIONS" always;
    
    # Content type
    add_header Content-Type "application/dash+xml" always;
}

# DASH segment files
location ~ \.(m4s|m4a|m4v)$ {
    # Cache segments
    expires 1h;
    add_header Cache-Control "public, max-age=3600";
    
    # CORS for DASH
    add_header Access-Control-Allow-Origin $cors_origin always;
}

# ==========================================================================
# Slice Module Configuration for Large File Caching
# ==========================================================================
#
# The slice module is configured in cache.conf:
# slice 1m;
# proxy_cache_key $uri$is_args$args$slice_range;
#
# This enables caching of byte ranges independently, which is essential for:
# - Efficient seeking in large media files
# - Reduced bandwidth when users don't watch entire videos
# - Better cache utilization
#
# ==========================================================================

# ==========================================================================
# Bandwidth Limiting (Optional)
# ==========================================================================

# Uncomment to limit bandwidth per connection
# Useful for preventing single users from consuming all bandwidth

# location ~ ^/stream/ {
#     # Limit rate after initial burst
#     limit_rate_after 5m;
#     limit_rate 1m;  # 1 MB/s after first 5 MB
# }

# ==========================================================================
# Preload Hints
# ==========================================================================

# Respond to preload requests quickly
# Used by browsers to hint at upcoming resource needs

# location = /stream/preload {
#     # Quick response for preload validation
#     return 200 "";
#     add_header Content-Length 0 always;
# }

# ==========================================================================
# Media Quality Selection
# ==========================================================================

# Map for quality parameter handling
map $arg_quality $media_quality {
    default "auto";
    "low" "32k";
    "medium" "64k";
    "high" "128k";
    "hd" "256k";
}

# ==========================================================================
# Metrics for Media Streaming
# ==========================================================================

# Log format for media requests
log_format media '$remote_addr - [$time_local] "$request" '
                 '$status $bytes_sent "$http_range" '
                 'rt=$request_time '
                 'cache=$upstream_cache_status';

# Uncomment to enable media logging
# access_log /var/log/nginx/media.log media;

# ==========================================================================
# Performance Notes for Media Streaming
# ==========================================================================
#
# 1. Range Requests:
#    - Essential for seeking and resumable downloads
#    - Nginx handles this automatically for static files
#    - For proxied content, ensure upstream supports ranges
#
# 2. Slice Caching:
#    - Breaks large files into cacheable chunks
#    - Improves cache hit ratio for large media
#    - Set slice size based on typical seek patterns (1m is good default)
#
# 3. Buffer Sizing:
#    - Larger buffers reduce disk I/O
#    - Balance with memory usage
#    - proxy_buffer_size should fit typical response headers
#
# 4. Sendfile + TCP_NOPUSH:
#    - Zero-copy serving for static files
#    - Reduces CPU usage significantly
#    - tcp_nopush sends full packets for efficiency
#
# 5. AIO Threads:
#    - Async I/O prevents blocking on disk reads
#    - Important for high-concurrency streaming
#    - Requires nginx compiled with threads support
#
# ==========================================================================
